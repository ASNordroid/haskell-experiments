-- {-# LANGUAGE TypeSynonymInstances #-}
-- {-# LANGUAGE FlexibleInstances #-}
import Data.List


type Tile = [[Int]]

-- instance Show Tile where
--      show = init . unlines . map (pr =<<) where
--           pr x = if x == 1 then "▓" else "░"

-- TODO: read tiles from file
a = [[0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [1,1,1,1,1,1,1],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0]]
b = [[0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,0,0,0,0],
     [1,1,0,0,0,1,1],
     [0,0,0,0,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0]]
c = [[1,1,1,1,1,1,1],
     [1,0,0,0,0,0,1],
     [1,0,0,0,0,0,1],
     [1,0,0,0,0,0,1],
     [1,0,0,0,0,0,1],
     [1,0,0,0,0,0,1],
     [1,1,1,1,1,1,1]]
d = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,1,0,1,0,0],
     [0,0,1,0,1,0,0],
     [0,0,1,1,1,0,0]]
e = [[0,0,1,1,1,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0]]
f = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,1,0,1,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0]]
g = [[0,0,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0]]
h = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,1,0,1,0,0],
     [0,1,1,0,1,1,0],
     [1,1,1,0,1,1,1]]
i = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0]]
j = [[0,0,1,1,1,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,1,0,1,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0]]
k = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,1,0,0,0],
     [1,1,1,1,1,1,1]]
l = [[1,1,1,0,1,1,1],
     [1,0,1,0,1,0,1],
     [1,1,1,0,1,1,1],
     [0,0,0,0,0,0,0],
     [1,1,1,0,1,1,1],
     [1,0,1,0,1,0,1],
     [1,1,1,0,1,1,1]]
m = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,1,1,1,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0]]
n = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0]]
o = [[0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0],
     [0,0,0,1,0,0,0],
     [0,0,1,1,1,0,0],
     [0,1,1,1,1,1,0],
     [1,1,1,1,1,1,1]]
p = [[0,0,0,1,0,0,0],
     [0,1,1,1,1,1,0],
     [0,1,1,0,1,1,0],
     [1,1,0,0,0,1,1],
     [0,1,1,0,1,1,0],
     [0,1,1,1,1,1,0],
     [0,0,0,1,0,0,0]]

xorL :: Tile -> Tile -> Tile
xorL a b = zipWith (zipWith xor) a b where
    xor a b = case (a, b) of
        (0, 0) -> 0
        (0, 1) -> 1
        (1, 0) -> 1
        (1, 1) -> 0
orL :: Tile -> Tile -> Tile
orL  a b = zipWith (zipWith orr) a b where
    orr a b = case (a, b) of
        (0, 0) -> 0
        (0, 1) -> 1
        (1, 0) -> 1
        (1, 1) -> 1
andL :: Tile -> Tile -> Tile
andL a b = zipWith (zipWith andd) a b where
    andd a b = case (a, b) of
        (0, 0) -> 0
        (0, 1) -> 0
        (1, 0) -> 0
        (1, 1) -> 1
notL :: Tile -> Tile
notL a   = map (map nott) a where
    nott a = case a of
        0 -> 1
        1 -> 0

-- goal = [[0,1,1,0,1,1,0],
--         [0,0,1,0,1,0,0],
--         [0,0,1,0,1,0,0],
--         [0,0,1,0,1,0,0],
--         [0,0,1,0,1,0,0],
--         [0,0,1,0,1,0,0],
--         [0,1,1,0,1,1,0]]
goal = notL [[0,0,0,1,0,0,0],
        [0,0,0,1,0,0,0],
        [0,0,1,1,1,0,0],
        [1,1,1,1,1,1,1],
        [0,0,1,1,1,0,0],
        [0,0,0,1,0,0,0],
        [0,0,0,1,0,0,0]]
tiles = [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p]


allc :: (Tile, Tile) -> [Tile]
allc a = z ++ map notL z where
    z = sequence (map uncurry [andL, orL, xorL]) a

-- TODO: add number of steps as parameter
containsQ = or $ map (any (check goal)) $ tiles : (map allc $ pairs tiles) where
    pairs l = [(x, y) | (x:ys) <- tails l, y <- ys]

    check :: Tile -> Tile -> Bool
    check a b = all id $ map (and . uncurry (zipWith (==))) $ zip a b

-- ? myshow a = init $ unlines $ map concat $ map (map pr) a
myshow :: Tile -> String
myshow = init . unlines . map (pr =<<) where
    pr x = if x == 1 then "▓" else "░" -- "■" else "□"


main :: IO ()
main = do
    putStrLn $ myshow b
    print containsQ
